# 1. 시간, 공간복잡도

- 컴퓨터는 1초에 대략 3-5억개의 연산을 수행.

```js
// 연산 수행 횟수 예제
function func1(arr, n) {
  let cnt: int = 0; // 1. 변수 선언 및 대입: 1

  // 2. 반복문 i의 초기값 대입: 1번
  // 3. 반복문 n번동안
  // 3-1. 반복문 조건 확인, i 증가: 2번
  for (let i = 0; i < n; i++) {
    // 3-2. arr[1] % 5 값, 조건 확인: 2번
    if (arr[i] % 5 === 0) {
      cnt++; // 3-3. cnt 증가: 1번
    }
  }
  return cnt; // 4. cnt 반환: 1번
}
```

- 총 연산 횟수: 1 + 1 + n x (2 + 2 + 1) + 1 = **5n + 3**  
  즉, n에 비례한다. => **O(N)**

## 시간복잡도 (Time Complexticy)

입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계

## 빅오표기법 (Big-O Notation)

주어진 식을 값이 가장 큰 대표항만 남겨서 나타내는 방법.

- **O(N)**: **5N**+3 | **2N**+10lgN | **10N**
- **O(N^2)**: **N^2**+2N+4 | **6N^2**+20N+10lgN
- **O(NlgN)**: **NlgN**+30N+10 | **5NlgN**+6
- **O(1)**: 5, 16, 36
- **O(lgN)**: 밑이 2인 로그 (밑이 10인 상용로그와 시간복잡도 차이는 없지만 컴퓨터는 이진수이므로)

## 수행시간

O(1) < O(lgN) < O(N) < O(NlgN) < O(N^2) < O(2^N) < O(N!)

> O(2^N): N이 25 이하 정도의 작은 수가 아니라면 시간제한 위험  
> O(N!): 12!는 대략 5억으로, N이 11 이하 정도가 아니라면 시간제한 위험

## N의 크기에 따른 허용 시간 복잡도

대략적으로 나타낸 표

|    N의 크기     | 허용 시간 복잡도 |
| :-------------: | :--------------: |
|     N <= 11     |      O(N!)       |
|     N <= 25     |      O(2^N)      |
|    N <= 100     |      O(N^4)      |
|    N <= 500     |      O(N^3)      |
|   N <= 3,000    |    O(N^2lgN)     |
|   N <= 5,000    |      O(N^2)      |
| N <= 1,000,000  |     O(NlgN)      |
| N <= 10,000,000 |       O(N)       |
|     그 이상     |   O(lgN), O(1)   |

## 공간 복잡도 (Space Complexity)

입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계. (메모리 제한)

- O(N^2): 크기가 N인 2차원 배열이 필요
- O(1): 따로 배열이 필요없음

대부분의 코딩테스트에서는 시간복잡도만 신경쓰면됨.  
그러나 문제를 풀 때 기억해두면 좋은 한가지는 `512MB = 1.2억개의 int` 이다.

- 코딩테스트에서 보통 메모리 사용량을 128 ~ 512MB로 제한한다.
- int 1개는 4Byte
- 예를 들면, 떠올린 풀이가 크기가 5억인 배열을 필요로 함. => 틀린 풀이

<br>

# 2. 정수 자료형

Integer Overflow를 주의해야한다.

- char: 1byte
- short: 2byte. 2^15 - 1(= 32767)
- int: 4byte. 2^31 - 1(= 2.1 X 10^9. 약 21억)
- long long: 8byte. 2^63 - 1(= 9.2 X 10^18)

## 자바스크립트에서의 숫자 범위

- Number: 최대 2^53 - 1
- BigInt: Number보다 큰 정수를 표현

<br>

# 3. 실수 자료형

- float: 4byte (= 32bit)
  - sign (1bit): 음수인지 양수인지 저장하는 필드 (1: 음수 / 0: 양수)
  - exponent (8bit): 지수를 저장하는 필드
  - faction (23bit): 유효숫자 부분을 저장하는 필드
- double: 8byte (= 64bit)

## 실수의 성질

1.  실수의 저장/연산 과정에서 반드시 오차가 발생할 수 밖에 없다.
    ```js
    const result = 0.1 + 0.1 + 0.1 == 0.3; // false
    ```
2.  dobule에 long long 범위의 정수를 함부로 담으면 안된다.  
    (유효숫자의 차이로 인해 오차가 섞인 값이 저장 될 수 있다.)
    - double: 유효숫자 15자리
    - long long: 유효숫자 최대 19자리
    - int: int는 최대 21억이기 때문에 double에 담아도 오차가 안생김.
3.  실수를 비교할 때는 등호를 사용하면 안된다.

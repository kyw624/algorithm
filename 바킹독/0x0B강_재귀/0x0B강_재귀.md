# 1. 알고리즘 설명

## 재귀란?

하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

## 예시

### 1. N부터 1까지 출력

```js
const recursive1 = (N) => {
  if (N === 0) return;
  console.log(N);
  recursive1(N - 1);
};

recursive1(10);
```

### 2. 1부터 N까지의 합

```js
const recursive2 = (N) => {
  if (N === 1) return N;
  return N + recursive2(N - 1);
};

recursive2(10);
```

## 수학적 귀납법

문제를 재귀로 푼다는건 귀납적인 방식으로 해결하는 것과 같은데  
기본적으로 귀납적이라는 것은 지금까지 우리의 상식과 큰 차이가 있다.

### 도미노 예시

1번 도미노가 쓰러지면 모든 도미노가 쓰러진다는 증명

- **일반적인 풀이 (절차지향적)**  
  1번이 쓰러지면 2번이 쓰러지고, 2번이 쓰러지면 3번이, ...

- **귀납적 사고**  
  k번이 쓰러지면 k+1도 쓰러진다는 참이므로 모든 도미노가 쓰러진다.

## 재귀 함수의 조건

- 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함. (Base condition)
- 모든 입력은 Base condition으로 수렴해야 함.

## 재귀에 대한 정보

1. 함수의 인자로 어떤 것을 받고, 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 한다.
2. 모든 재귀 함수는 반복문만으로도 동일한 동작을 하는 함수를 만들 수 있다.
3. 재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리/시간에서는 손해다.
   > 상황에 맞게 재귀 or 반복문 선택
   - 굳이 재귀가 필요없다면 반복문
   - 코드가 너무 복잡해진다면 재귀
4. 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음
   > ex) 피보나치: 이미 계산한 값을 계속해서 계산하게 됨.
5. 재귀함수가 자기 자신을 부를 때 스택 영역에 함수가 계속 누적이 됨.
